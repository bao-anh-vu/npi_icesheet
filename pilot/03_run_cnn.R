## Train a CNN on ice thickness and velocity data

setwd("/home/babv971/SSA_model/CNN/pilot")

rm(list = ls())

library(keras)
reticulate::use_condaenv("myenv", required = TRUE)
library(tensorflow)
library(ggplot2)

## Flags
# rerun_cnn <- F
save_pred <- T

## Read data
data_date <- "20240320"
set <- 1
train_data <- readRDS(file = paste0("./training_data/train_data_", data_date, ".rds"))
train_input <- train_data$train_input
val_input <- train_data$val_input
test_input <- train_data$test_input

train_output <- train_data$train_output
val_output <- train_data$val_output
test_output <- train_data$test_output

# if (rerun_cnn) {
    model <- keras_model_sequential() %>%
        layer_conv_2d(
            filters = 32, kernel_size = c(5, 5),
            padding = "same", activation = "relu",
            input_shape = c(2001, 50, 2)
        ) %>%
        layer_max_pooling_2d(pool_size = c(2, 2)) %>%
        layer_conv_2d(
            filters = 64, kernel_size = c(3, 3),
            padding = "same", activation = "relu"
        ) %>%
        layer_max_pooling_2d(pool_size = c(2, 2)) %>%
        layer_conv_2d(
            filters = 128, kernel_size = c(3, 3),
            padding = "same", activation = "relu"
        ) %>%
        layer_max_pooling_2d(pool_size = c(2, 2)) %>%
        # layer_conv_2d(filters = 256, kernel_size = c(3, 3),
        #                 padding = "same", activation = "relu") %>%
        layer_max_pooling_2d(pool_size = c(2, 2)) %>%
        layer_flatten() %>%
        layer_dropout(rate = 0.5) %>%
        # layer_dense(units = 256, activation = "relu") %>%
        layer_dense(units = ncol(train_output))

    summary(model)

    model %>% compile(
        loss = "mse",
        optimizer = optimizer_adam(),
        metrics = list("mean_squared_error")
    )
    history <- model %>% fit(train_input, train_output,
        epochs = 1000,
        batch_size = 64,
        validation_data = list(val_input, val_output)
    )

    pred_coefs <- model %>% predict(test_input)

    if (save_pred) {
        saveRDS(history, file = paste0("./output/history_", set, "_", data_date, ".rds"))
        
        saveRDS(model, file = paste0("./output/cnn_model_", set, "_", data_date, ".rds"))
        ## Save predicted friction coefs
        saveRDS(pred_coefs, file = paste0("./output/pred_coefs_", set, "_", data_date, ".rds"))
    }
# } 
# else {
#     pred_coefs <- readRDS(file = paste0("./training_data/pred_coefs_", set, "_", data_date, ".rds"))
# }

## Plot the predicted friction coefs generated by these basis functions
## And compare them to the original friction coefs ---- move to separate file later

# fric_basis <- readRDS(file = paste0("./training_data/friction_basis_", set, "_", data_date, ".rds"))
# basis_mat <- cbind(rep(1, nrow(basis_mat)), fric_basis$basis_mat)
# pred_fric <- basis_mat %*% t(pred_coefs)
# original_fric <- basis_mat %*% t(test_output)
# matplot(pred_fric, type = "l")

# par(mfrow = c(nrow(test_output)/2, 2))

# for (i in 1:nrow(test_output)) {
#     plot(original_fric[, i], type = "l", lwd = 2, ylab = "Friction (unit)", xlab = "Domain (km)")
#     lines(pred_fric[, i], col = "red", lwd = 2)
# }
