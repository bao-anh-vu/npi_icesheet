## Post-process output from CNN
setwd("/home/babv971/SSA_model/CNN/pilot/")

rm(list = ls())
source("source/create_model.R")
library(keras)
reticulate::use_condaenv("myenv", required = TRUE)
library(tensorflow)
library(ggplot2)

## Flags
output_var <- "grounding_line" # "friction" # "grounding_line" # "bed_elevation
save_plots <- T

## Read data
data_date <- "20240320"
sets <- 1:10
# setf <- formatC(set, width=2, flag="0")
setsf <- paste0("sets", sets[1], "-", sets[length(sets)])

# train_data <- readRDS(file = paste0("./training_data/", setsf, "/train_data_", data_date, ".rds"))
test_data <- readRDS(file = paste0("./training_data/", output_var, "/", setsf, "/test_data_", data_date, ".rds"))
ssa_steady <- readRDS(file = paste("./training_data/initial_conds/ssa_steady_20220329.rds", sep = ""))
domain <- ssa_steady$domain

## Load the model
# train_input <- train_data$input
# val_input <- val_data$input
test_input <- test_data$input

# train_output <- train_data$output
# val_output <- val_data$output
test_output <- test_data$output

output_dim <- ncol(test_output)
model <- create_model(output_dim)

# Display the model's architecture
summary(model)

## Plot the loss
history <- readRDS(file = paste0("./output/", output_var, "/", setsf, "/history_", data_date, ".rds"))
# history %>% plot() #+
# coord_cartesian(xlim = c(1, epochs))

plot(history$metrics$val_loss[2:100], type = "l")
lines(history$metrics$loss[2:100], col = "red")
legend("topright", legend = c("Training", "Validation"), col = c("black", "red"), lty = 1, cex = 0.8)

plot_dir <- paste0("./plots/", output_var, "/", setsf)
if (save_plots) {

    if (!dir.exists(plot_dir)) {
        dir.create(plot_dir)
    }

    png(paste0(plot_dir, "/loss.png"), width = 1000, height = 500)
    plot(history$metrics$val_loss[2:100], type = "l")
    lines(history$metrics$loss[2:100], col = "red")
    legend("topright", legend = c("Training", "Validation"), col = c("black", "red"), lty = 1, cex = 0.8)
    dev.off()
}

## Extract the friction coefficients and grounding line
# test_fric_coefs <- test_output[, 1:150]
# test_gl <- test_output[, 151:200]


## Then transform them back to original scale
output_mean <- test_data$output_mean
output_sd <- test_data$output_sd

test_output <- test_output * output_sd + output_mean
# test_fric_coefs <- test_output[, 1:150]
# test_gl <- test_output[, 151:200]


## Reload model from checkpoint
checkpoint_path <- paste0("output/", output_var, "/", setsf, "/checkpoints/cp-{epoch:04d}.ckpt")
checkpoint_dir <- fs::path_dir(checkpoint_path)

checkpt <- which.min(history$metrics$val_loss) # c(69)
# for (checkpt in checkpts) {
if (!is.null(checkpt)) {
    ## Load the model from checkpt
    cp_restart <- paste0("output/", output_var, "/", setsf, "/checkpoints/cp-", formatC(checkpt, width = 4, flag = "0"), ".ckpt")
    # latest <- tf$train$latest_checkpoint(checkpoint_dir)
    load_model_weights_tf(model, cp_restart)
} else {
    latest <- tf$train$latest_checkpoint(checkpoint_dir)
    load_model_weights_tf(model, latest)
}

## Predict
pred_output <- model %>% predict(test_input)
pred_output <- pred_output * output_sd + output_mean # un-standardise output

# pred_coefs <- pred_output_unstd[, 1:150]
# pred_gl <- pred_output_unstd[, 151:200]


## Plot the predicted friction coefs generated by these basis functions
samples <- sample(1:nrow(test_output), 6)

par(mfrow = c(length(samples) / 2, 2))

if (output_var == "friction") {
    ## Matrix of basis functions
    fric_basis <- readRDS(file = paste0("./training_data/friction_basis_01_", data_date, ".rds"))
    basis_mat <- fric_basis$basis_mat

    ## Compute predicted vs original friction coefficients
    pred_fric <- basis_mat %*% t(pred_coefs)
    test_fric <- basis_mat %*% t(test_fric_coefs)

    ## Friction plot
    for (i in 1:length(samples)) {
        par(mar = c(6, 8, 4, 2))
        gl <- test_data$grounding_line[i] / 800 * 2001
        plot_domain <- 1:length(domain) # ceiling(gl)
        plot(domain[plot_domain] / 1000, pred_fric[plot_domain, i],
            type = "l", lwd = 2, col = "red",
            ylab = "Friction (unit)", xlab = "Domain (km)", cex.axis = 3, cex.lab = 4
        )
        lines(domain[plot_domain] / 1000, test_fric[plot_domain, i], lwd = 2)
        abline(v = test_data$test_gl[i], lwd = 3, lty = 2)
    }
} else if (output_var == "grounding_line") {

    pred_gl <- pred_output
    test_gl <- test_output

    ## Grounding line plot
    for (i in 1:length(samples)) {
        par(mar = c(6, 8, 4, 2))
        plot_domain <- 1:length(domain) # ceiling(gl)
        plot(test_gl[i, ], 1:ncol(test_gl),
            type = "l", lwd = 2,
            xlab = "Grounding line (km)", ylab = "Time (years)", cex.axis = 3, cex.lab = 4
        )
        lines(pred_gl[i, ], 1:ncol(test_gl), col = "red", lwd = 2)
    } 
}else {
    print("Output variable not recognised.")
}


if (save_plots) {

    if (output_var == "friction") {
        png(paste0("./plots/", output_var, "/", setsf, "/pred_vs_test_fric_", setsf, "_ckpt", checkpt, ".png"), width = 2500, height = 2500)

        par(mfrow = c(length(samples) / 2, 2))

        for (i in 1:length(samples)) {
            par(mar = c(6, 8, 4, 2))
            gl <- test_data$grounding_line[i] / 800 * 2001
            plot_domain <- 1:length(domain) # ceiling(gl)
            plot(domain[plot_domain] / 1000, pred_fric[plot_domain, i],
                type = "l", lwd = 2, col = "red",
                ylab = "Friction (unit)", xlab = "Domain (km)", cex.axis = 3, cex.lab = 4
            )
            lines(domain[plot_domain] / 1000, test_fric[plot_domain, i], lwd = 2)
            abline(v = test_data$test_gl[i], lwd = 3, lty = 2)
        }
        dev.off()
    } else if (output_var == "grounding_line") {
        ## Grounding line plot
        png(paste0("./plots/", output_var, "/", setsf, "/pred_vs_test_gl_", setsf, "_ckpt", checkpt, ".png"), width = 2500, height = 2500)
        par(mfrow = c(length(samples) / 2, 2))

        for (i in 1:length(samples)) {
            par(mar = c(6, 8, 4, 2))
            plot_domain <- 1:length(domain) # ceiling(gl)
            plot(test_gl[i, ], 1:ncol(test_gl),
                type = "l", lwd = 2,
                xlab = "Grounding line (km)", ylab = "Time (years)", cex.axis = 3, cex.lab = 4
            )
            lines(pred_gl[i, ], 1:ncol(test_gl), col = "red", lwd = 2)
        }
        dev.off()
    } else {
        print("Output variable not recognised.")
    }
    
}

## RMSE
rmse <- function(truth, pred) {
    sqrt(mean((truth - pred)^2))
}

total_rmse <- 0
if (output_var == "friction") {
    truth <- test_fric
    pred <- pred_fric
} else if (output_var == "grounding_line") {
   truth <- test_gl
   pred <- pred_gl
}

for (s in 1:ncol(test_output)) {
    total_rmse <- total_rmse + rmse(test_fric[, s], pred_fric[, s])
}
cat("RMSE: ", total_rmse / ncol(test_fric), "\n") # normalise by number of simulations in the test set

# }


# history <- readRDS(file = paste0("./output/history_", setf, "_", data_date, ".rds"))
# # par(mfrow = c(1, 1))
# png(paste0("plots/hist.png"), width = 1000, height = 500)
# plot(history$metrics$loss[-1], type = "l", col = "red")
# lines(history$metrics$val_loss[-1])
# dev.off()

# png(paste0("plots/hist_100.png"), width = 1000, height = 500)
# plot(history$metrics$loss[2:100], type = "l", col = "red")
# lines(history$metrics$val_loss[2:100])
# dev.off()


# png(paste0("plots/hist_69.png"), width = 1000, height = 500)
# plot(history$metrics$val_loss[2:69], type = "l", col = "red")
# lines(history$metrics$loss[2:69])
# dev.off()
