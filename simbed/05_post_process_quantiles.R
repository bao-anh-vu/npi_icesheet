## Post-process output from CNN
setwd("~/SSA_model/CNN/simbed/")

rm(list = ls())
source("./source/create_model.R")
source("./source/custom_loss_function.R")

library(keras)
reticulate::use_condaenv("myenv", required = TRUE)
library(tensorflow)
library(ggplot2)

## Flags
output_var <- "all" # "friction" # "grounding_line" # "bed_elevation
# sim_beds <- T
save_plots <- T

## Read data
data_date <- "20240320"
sets <- 1:5
# setf <- formatC(set, width=2, flag="0")
setsf <- paste0("sets", sets[1], "-", sets[length(sets)])


# if (sim_beds) {
data_dir <- paste0("./training_data/", setsf)
output_dir <- paste0("./output/", output_var, "/", setsf)
test_data <- readRDS(file = paste0(data_dir, "/test_data_", data_date, ".rds"))
ssa_steady <- readRDS(file = paste("./training_data/initial_conds/ssa_steady_20220329.rds", sep = ""))
domain <- ssa_steady$domain

## Load the model
# train_input <- train_data$input
# val_input <- val_data$input
test_input <- test_data$input

# train_output <- train_data$output
# val_output <- val_data$output87
# test_output <- test_data$output
# true_params <- test_data$truth

# if (sim_beds) {
if (output_var == "friction") {
    test_output <- test_data$fric_coefs
    
} else if (output_var == "grounding_line") {
    test_output <- test_data$grounding_line
} else if (output_var == "bed") {
    test_output <- test_data$bed_coefs
} else if (output_var == "all") {
    test_output <- cbind(test_data$fric_coefs, test_data$bed_coefs, test_data$grounding_line)
} else {
    print("Output variable should be either 'friction', 'bed' or 'grounding_line'.")
}

input_dim <- dim(test_input)[2:4]
output_dim <- ncol(test_output)
model <- create_model(input_dim = input_dim, output_dim = output_dim)

# Display the model's architecture
summary(model)

## Plot the loss
history <- readRDS(file = paste0(output_dir, "/history_", data_date, ".rds"))
# history %>% plot() #+
# coord_cartesian(xlim = c(1, epochs))

plot(history$metrics$loss[2:100], type = "l")
lines(history$metrics$val_loss[2:100], col = "red")
legend("topright", legend = c("Training", "Validation"), col = c("black", "red"), lty = 1, cex = 0.8)

# if (sim_beds) {
    plot_dir <- paste0("./plots/", output_var, "/", setsf)
# } else {
#     plot_dir <- paste0("./plots/", output_var, "/", setsf)
# }

if (save_plots) {

    if (!dir.exists(plot_dir)) {
        dir.create(plot_dir)
    }

    png(paste0(plot_dir, "/loss_", output_var, ".png"), width = 1000, height = 500)
    plot(history$metrics$loss[2:100], type = "l")
    lines(history$metrics$val_loss[2:100], col = "red")
    legend("topright", legend = c("Training", "Validation"), col = c("black", "red"), lty = 1, cex = 0.8)
    dev.off()
}


## Extract the friction coefficients and grounding line
# test_fric_coefs <- test_output[, 1:150]
# test_gl <- test_output[, 151:200]


## Then transform them back to original scale
# output_mean <- test_data$output_mean
# output_sd <- test_data$output_sd

# test_output <- test_output * output_sd + output_mean

## Reload model from checkpoint
checkpoint_path <- paste0(output_dir, "/checkpoints/cp-{epoch:04d}.ckpt")
checkpoint_dir <- fs::path_dir(checkpoint_path)

checkpt <- which.min(history$metrics$val_loss) # c(69)
# for (checkpt in checkpts) {
if (!is.null(checkpt)) {
    ## Load the model from checkpt
    cp_restart <- paste0(output_dir, "/checkpoints/cp-", formatC(checkpt, width = 4, flag = "0"), ".ckpt")
    # latest <- tf$train$latest_checkpoint(checkpoint_dir)
    load_model_weights_tf(model, cp_restart)
} else {
    latest <- tf$train$latest_checkpoint(checkpoint_dir)
    load_model_weights_tf(model, latest)
}

## Predict
pred_output <- model %>% predict(test_input)

## Plot the predicted friction coefs generated by these basis functions

if (output_var == "all") {
    fric_basis_mat <- test_data$fric_basis_mat
    bed_basis_mat <- test_data$bed_basis_mat
    n_fric_basis <- ncol(fric_basis_mat)
    n_bed_basis <- ncol(bed_basis_mat)

    ## Un-standardise output
    pred_fric_coefs <- pred_output[, 1:n_fric_basis] * test_data$sd_fric_coefs + test_data$mean_fric_coefs
    pred_bed_coefs <- pred_output[, (n_fric_basis+1):(n_fric_basis+n_bed_basis)] * test_data$sd_bed_coefs + test_data$mean_bed_coefs
    pred_gl <- pred_output[, (n_fric_basis+n_bed_basis+1):ncol(pred_output)] * test_data$sd_gl + test_data$mean_gl

    test_fric_coefs <- test_output[, 1:n_fric_basis] * test_data$sd_fric_coefs + test_data$mean_fric_coefs
    test_bed_coefs <- test_output[, (n_fric_basis+1):(n_fric_basis+n_bed_basis)] * test_data$sd_bed_coefs + test_data$mean_bed_coefs
    test_gl <- test_output[, (n_fric_basis+n_bed_basis+1):ncol(pred_output)] * test_data$sd_gl + test_data$mean_gl

    ## Compute predicted vs original friction
    pred_fric <- fric_basis_mat %*% t(pred_fric_coefs)
    test_fric <- fric_basis_mat %*% t(test_fric_coefs)

    ## Compute predicted vs original bed elevations
    pred_bed_demean <- bed_basis_mat %*% t(pred_bed_coefs)
    test_bed_demean <- bed_basis_mat %*% t(test_bed_coefs)


} else {
    stop("Output not available for this variable.")
}

############################
##        Quantiles       ##
############################
quantiles <- c(0.05, 0.95)
pred_quantiles <- list()

for (q in 1:length(quantiles)) {
    quantile <- quantiles[q]
    output_dir_quantile <- paste0("./output/", output_var, "/", setsf, "/quantile", quantile*100)

    model_quantile <- create_model_quantile(input_dim = input_dim, output_dim = output_dim, quantile = quantile)

    history_quantile <- readRDS(file = paste0(output_dir_quantile, "/history_", data_date, ".rds"))
    # history %>% plot() #+
    # coord_cartesian(xlim = c(1, epochs))
    par(mfrow = c(2,1))
    plot(history_quantile$metrics$loss[2:100], type = "l", 
            xlab = "Iteration", ylab = "Loss",
            main = paste0("Loss when training the", quantile*100, "th quantile"))
    lines(history_quantile$metrics$val_loss[2:100], col = "red")
    legend("topright", legend = c("Training", "Validation"), 
            col = c("black", "red"), lty = 1, cex = 0.8)

    ## Reload model for quantile from checkpoint
    checkpoint_path_quantile <- paste0(output_dir_quantile, "/checkpoints/cp-{epoch:04d}.ckpt")
    checkpoint_dir_quantile <- fs::path_dir(checkpoint_path_quantile)

    checkpt_quantile <- which.min(history_quantile$metrics$val_loss) # c(69)
    # for (checkpt in checkpts) {
    if (!is.null(checkpt_quantile)) {
        ## Load the model from checkpt
        cp_restart_quantile <- paste0(output_dir_quantile, "/checkpoints/cp-", formatC(checkpt_quantile, width = 4, flag = "0"), ".ckpt")
        # latest <- tf$train$latest_checkpoint(checkpoint_dir)
        load_model_weights_tf(model_quantile, cp_restart_quantile)
    } else {
        latest_cp_quantile <- tf$train$latest_checkpoint(checkpoint_dir_quantile)
        load_model_weights_tf(model_quantile, latest_cp_quantile)
    }

    ## Predict
    pred_output_quantile <- model_quantile %>% predict(test_input)

    ## Un-standardise output
    pred_fric_coefs_quantile <- pred_output_quantile[, 1:n_fric_basis] * test_data$sd_fric_coefs + test_data$mean_fric_coefs
    pred_bed_coefs_quantile <- pred_output_quantile[, (n_fric_basis+1):(n_fric_basis+n_bed_basis)] * test_data$sd_bed_coefs + test_data$mean_bed_coefs
    pred_gl_quantile <- pred_output_quantile[, (n_fric_basis+n_bed_basis+1):ncol(pred_output_quantile)] * test_data$sd_gl + test_data$mean_gl

    # test_fric_coefs_quantile <- test_output[, 1:n_fric_basis] * test_data$sd_fric_coefs + test_data$mean_fric_coefs
    # test_bed_coefs_quantile <- test_output[, (n_fric_basis+1):(n_fric_basis+n_bed_basis)] * test_data$sd_bed_coefs + test_data$mean_bed_coefs
    # test_gl_quantile <- test_output[, (n_fric_basis+n_bed_basis+1):ncol(pred_output)] * test_data$sd_gl + test_data$mean_gl

    ## Compute predicted vs original friction
    pred_fric_quantile <- fric_basis_mat %*% t(pred_fric_coefs_quantile)
    # test_fric <- fric_basis_mat %*% t(test_fric_coefs)

    ## Compute predicted vs original bed elevations
    pred_bed_quantile <- bed_basis_mat %*% t(pred_bed_coefs_quantile)
    # test_bed_demean <- bed_basis_mat %*% t(test_bed_coefs)

    pred_quantiles[[q]] <- list(fric = pred_fric_quantile, bed = pred_bed_quantile, gl = pred_gl_quantile)
}

########### end quantile ################

## True parameters
true_fric <- test_data$true_fric

## Scaling units for friction coefficients
secpera <- 31556926
fric_scale <- 1e6 * secpera^(1/3)

true_fric <- true_fric/fric_scale
true_bed <- test_data$true_bed
true_gl <- test_data$grounding_line * test_data$sd_gl + test_data$mean_gl

## Add bed trend to the predicted oscillations
bed_obs <- readRDS(file = paste0("./training_data/bed_obs_", data_date, ".rds"))
df <- data.frame(obs_locations = domain[bed_obs$locations], bed_elev = bed_obs$obs)
bed.fit <- loess(bed_elev ~ obs_locations, data = df, span = 0.25, 
                    control = loess.control(surface = "direct")) 
bed_mean <- predict(bed.fit, newdata = data.frame(obs_locations = domain))
mean_mat <- matrix(rep(bed_mean), nrow = length(bed_mean), ncol = ncol(pred_bed_demean))

pred_bed <- pred_bed_demean + mean_mat
test_bed <- test_bed_demean + mean_mat

pred_bed_lq <- pred_quantiles[[1]]$bed + mean_mat
pred_bed_uq <- pred_quantiles[[2]]$bed + mean_mat

pred_fric_lq <- pred_quantiles[[1]]$fric
pred_fric_uq <- pred_quantiles[[2]]$fric

pred_gl_lq <- pred_quantiles[[1]]$gl
pred_gl_uq <- pred_quantiles[[2]]$gl

## Plots

samples <- sample(1:nrow(test_output), 6)

par(mfrow = c(length(samples) / 2, 2))

# if (output_var == "bed" | output_var == "all") {
    ## Bed plot
    for (i in 1:length(samples)) {
        par(mar = c(6, 8, 4, 2))
        # gl <- test_data$grounding_line[i] / 800 * 2001
        plot_domain <- 1:length(domain) # ceiling(gl)
        plot(domain[plot_domain] / 1000, true_bed[i, plot_domain],
            type = "l", lwd = 2, col = "black",
            ylab = "Bed (m)", xlab = "Domain (km)", cex.axis = 3, cex.lab = 4
        )
        # lines(domain[plot_domain] / 1000, test_bed[plot_domain, i], lwd = 2, col = "blue")
        lines(domain[plot_domain] / 1000, pred_bed[plot_domain, i], lwd = 3, col = "red")
        lines(domain[plot_domain] / 1000, pred_bed_lq[plot_domain, i], lty = 3, lwd = 3, col = "salmon")
        lines(domain[plot_domain] / 1000, pred_bed_uq[plot_domain, i], lty = 3, lwd = 3, col = "salmon")
        
        abline(v = test_data$test_gl[i], lwd = 3, lty = 2)
    }
# }
 
# if (output_var == "friction" | output_var == "all") {
    ## Friction plot
    for (i in 1:length(samples)) {
        par(mar = c(6, 8, 4, 2))
        gl <- test_data$grounding_line[i] / 800 * 2001
        plot_domain <- 1:length(domain) # ceiling(gl)
        plot(domain[plot_domain] / 1000, true_fric[i, plot_domain],
            type = "l", lwd = 2, 
            ylab = "Friction (unit)", xlab = "Domain (km)", cex.axis = 3, cex.lab = 4
        )
        # lines(domain[plot_domain] / 1000, test_fric[plot_domain, i], lwd = 2, col = "blue")
        lines(domain[plot_domain] / 1000, pred_fric[plot_domain, i], lwd = 2, col = "red")
        lines(domain[plot_domain] / 1000, pred_fric_lq[plot_domain, i], lty = 3, lwd = 2, col = "salmon")
        lines(domain[plot_domain] / 1000, pred_fric_uq[plot_domain, i], lty = 3, lwd = 2, col = "salmon")
        
        abline(v = test_data$test_gl[i], lwd = 3, lty = 2)
    }

# }

# if (output_var == "grounding_line" | output_var == "all") {
    ## Grounding line plot
    for (i in 1:length(samples)) {
        par(mar = c(6, 8, 4, 2))
        # gl <- test_data$grounding_line[i] / 800 * 2001
        plot_domain <- 1:length(domain) # ceiling(gl)
        plot(true_gl[i, ], 1:20,
            type = "l", lwd = 2, 
            xlab = "Grounding line (km)", ylab = "Time (year)", cex.axis = 3, cex.lab = 4
        )
        # lines(domain[plot_domain] / 1000, test_fric[i, ], lwd = 2, col = "blue")
        lines(pred_gl[i, ], 1:20, lwd = 2, col = "red")
        lines(pred_gl_lq[i, ], 1:20, lty = 3, lwd = 2, col = "salmon")
        lines(pred_gl_uq[i, ], 1:20, lty = 3, lwd = 2, col = "salmon")
        
        # abline(v = test_data$test_gl[i], lwd = 3, lty = 2)
    }
# }


if (save_plots) {
    
    ## Bed plot
    png(paste0(plot_dir, "/pred_vs_true_bed", checkpt, ".png"), width = 2000, height = 2000)
    par(mfrow = c(length(samples) / 2, 2))

    # if (output_var == "bed" | output_var == "all") {
        for (i in 1:length(samples)) {
            par(mar = c(6, 8, 4, 2))
            # gl <- test_data$grounding_line[i] / 800 * 2001
            plot_domain <- 1:length(domain) # ceiling(gl)
            plot(domain[plot_domain] / 1000, true_bed[i, plot_domain],
                type = "l", lwd = 2, col = "black",
                ylab = "Bed (m)", xlab = "Domain (km)", cex.axis = 3, cex.lab = 4
            )
            # lines(domain[plot_domain] / 1000, test_bed[plot_domain, i], lwd = 2, col = "blue")
            lines(domain[plot_domain] / 1000, pred_bed[plot_domain, i], lwd = 3, col = "red")
            lines(domain[plot_domain] / 1000, pred_bed_lq[plot_domain, i], lty = 2, lwd = 3, col = "salmon")
            lines(domain[plot_domain] / 1000, pred_bed_uq[plot_domain, i], lty = 2, lwd = 3, col = "salmon")
            
            abline(v = test_data$test_gl[i], lty = 1, lwd = 3)
        }
    # }
    dev.off()

    png(paste0(plot_dir, "/pred_vs_true_fric", checkpt, ".png"), width = 2000, height = 1200)
    par(mfrow = c(length(samples) / 2, 2))

    # if (output_var == "friction" | output_var == "all") {
        ## Friction plot
        for (i in 1:length(samples)) {
            par(mar = c(6, 8, 4, 2))
            gl <- test_data$grounding_line[i] / 800 * 2001
            plot_domain <- 1:length(domain) # ceiling(gl)
            plot(domain[plot_domain] / 1000, true_fric[i, plot_domain],
                type = "l", lwd = 2, 
                ylab = "Friction (unit)", xlab = "Domain (km)", cex.axis = 3, cex.lab = 4
            )
            # lines(domain[plot_domain] / 1000, test_fric[plot_domain, i], lwd = 2, col = "blue")
            lines(domain[plot_domain] / 1000, pred_fric[plot_domain, i], lwd = 2, col = "red")
            lines(domain[plot_domain] / 1000, pred_fric_lq[plot_domain, i], lty = 2, lwd = 2, col = "salmon")
            lines(domain[plot_domain] / 1000, pred_fric_uq[plot_domain, i], lty = 2, lwd = 2, col = "salmon")
            
            abline(v = test_data$test_gl[i], lty = 1, lwd = 3)
        }
    # }
    dev.off()

    ## Grounding line plot
    
    png(paste0(plot_dir, "/pred_vs_true_gl", checkpt, ".png"), width = 2000, height = 2000)
    par(mfrow = c(length(samples) / 2, 2))

    for (i in 1:length(samples)) {
        par(mar = c(6, 8, 4, 2))
        # gl <- test_data$grounding_line[i] / 800 * 2001
        plot_domain <- 1:length(domain) # ceiling(gl)
        plot(true_gl[i, ], 1:20,
            type = "l", lwd = 2, 
            xlab = "Grounding line (km)", ylab = "Time (year)", cex.axis = 3, cex.lab = 4
        )
        # lines(domain[plot_domain] / 1000, test_fric[i, ], lwd = 2, col = "blue")
        lines(pred_gl[i, ], 1:20, lwd = 2, col = "red")
        lines(pred_gl_lq[i, ], 1:20, lty = 2, lwd = 3, col = "salmon")
        lines(pred_gl_uq[i, ], 1:20, lty = 2, lwd = 3, col = "salmon")
        
        # abline(v = test_data$test_gl[i], lwd = 3, lty = 2)
    }

    dev.off()
}

############################################# RMSE ##################################################
rmse <- function(truth, pred) {
    sqrt(mean((truth - pred)^2))
}

total_rmse <- 0
if (output_var == "friction") {## Post-process output from CNN
    truth <- test_fric
    pred <- pred_fric
} else if (output_var == "grounding_line") {
   truth <- test_gl
   pred <- pred_gl
} else if (output_var == "bed") {
    truth <- test_bed
    pred <- pred_bed
} else if (output_var == "all") {
    truth <- cbind(test_fric, test_bed)
    pred <- cbind(pred_fric, pred_bed)
} else {
    print("Output variable should be either 'friction', 'bed' or 'grounding_line'.")
}

for (s in 1:ncol(truth)) {
    total_rmse <- total_rmse + rmse(truth[, s], pred[, s])
}
cat("RMSE: ", total_rmse / ncol(truth), "\n") # normalise by number of simulations in the test set

# }


# history <- readRDS(file = paste0("./output/history_", setf, "_", data_date, ".rds"))
# # par(mfrow = c(1, 1))
# png(paste0("plots/hist.png"), width = 1000, height = 500)
# plot(history$metrics$loss[-1], type = "l", col = "red")
# lines(history$metrics$val_loss[-1])
# dev.off()

# png(paste0("plots/hist_100.png"), width = 1000, height = 500)
# plot(history$metrics$loss[2:100], type = "l", col = "red")
# lines(history$metrics$val_loss[2:100])
# dev.off()


# png(paste0("plots/hist_69.png"), width = 1000, height = 500)
# plot(history$metrics$val_loss[2:69], type = "l", col = "red")
# lines(history$metrics$loss[2:69])
# dev.off()
