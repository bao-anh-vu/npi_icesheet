## Post-process output from CNN
setwd("/home/babv971/SSA_model/CNN/")

rm(list = ls())
source("source/create_model.R")
library(keras)
reticulate::use_condaenv("myenv", required = TRUE)
library(tensorflow)
library(ggplot2)

## Read data
data_date <- "20240320"
sets <- 1:3
# setf <- formatC(set, width=2, flag="0")
setf <- paste0("sets", sets[1], "-", sets[length(sets)])

train_data <- readRDS(file = paste0("./training_data/train_data_", setf, "_", data_date, ".rds"))
ssa_steady <- readRDS(file = paste("./training_data/initial_conds/ssa_steady_20220329.rds", sep = ""))
domain <- ssa_steady$domain

## Load the model
train_input <- train_data$train_input
val_input <- train_data$val_input
test_input <- train_data$test_input

train_output <- train_data$train_output
val_output <- train_data$val_output
test_output <- train_data$test_output

model <- create_model()

# Display the model's architecture
summary(model)

## Matrix of basis functions
fric_basis <- readRDS(file = paste0("./training_data/friction_basis_01_", data_date, ".rds"))
basis_mat <- fric_basis$basis_mat

test_coefs <- train_data$test_output
test_fric <- basis_mat %*% t(test_coefs)
    

## Plot the loss
history <- readRDS(file = paste0("./output/history_", setf, "_", data_date, ".rds"))
history %>% plot() #+
# coord_cartesian(xlim = c(1, epochs))

## Get rid of first training loss
plot(history$metrics$loss[2:100],type = "l")
lines(history$metrics$val_loss[2:100], col = "red") 

checkpoint_path <- paste0("output/checkpoints", setf, "/:/cp-{epoch:04d}.ckpt")
checkpoint_dir <- fs::path_dir(checkpoint_path)

# Reload model from checkpoints
checkpt <- which.min(history$metrics$val_loss) #c(69)
# checkpt <- 69
# checkpts <- 11:20
# for (checkpt in checkpts) {
    if (!is.null(checkpt)) {
        ## Load the model from checkpt
        cp_restart <- paste0("output/checkpoints", setf, "/cp-", formatC(checkpt, width = 4, flag = "0"), ".ckpt")
        # latest <- tf$train$latest_checkpoint(checkpoint_dir)
        load_model_weights_tf(model, cp_restart)
    } else {
        latest <- tf$train$latest_checkpoint(checkpoint_dir)
        load_model_weights_tf(model, latest)
    }

    ## Predict
    pred_coefs <- model %>% predict(test_input)

    ## Plot the predicted friction coefs generated by these basis functions

    ## Compute predicted vs original friction coefficients
    pred_fric <- basis_mat %*% t(pred_coefs)

    samples <- sample(1:ncol(pred_coefs), 10)
    png(paste0("plots/pred_vs_test_fric_", setf, "_ckpt", checkpt, ".png"), width = 2500, height = 2500)

    par(mfrow = c(length(samples) / 2, 2))

    for (i in 1:length(samples)) {
        par(mar = c(6, 8, 4, 2))
        gl <- train_data$test_gl[i]/800*2001 
        plot_domain <- 1:ceiling(gl)
        plot(domain[plot_domain] / 1000, test_fric[plot_domain, i], type = "l", lwd = 2, 
        ylab = "Friction (unit)", xlab = "Domain (km)", cex.axis = 3, cex.lab = 4)
        lines(domain[plot_domain] / 1000, pred_fric[plot_domain, i], col = "red", lwd = 2)
        abline(v = train_data$test_gl[i], lwd = 3, lty = 2)
    }
    dev.off()
# }


# history <- readRDS(file = paste0("./output/history_", setf, "_", data_date, ".rds"))
# # par(mfrow = c(1, 1))
# png(paste0("plots/hist.png"), width = 1000, height = 500)
# plot(history$metrics$loss[-1], type = "l", col = "red")
# lines(history$metrics$val_loss[-1])
# dev.off()

# png(paste0("plots/hist_100.png"), width = 1000, height = 500)
# plot(history$metrics$loss[2:100], type = "l", col = "red")
# lines(history$metrics$val_loss[2:100])
# dev.off()


# png(paste0("plots/hist_69.png"), width = 1000, height = 500)
# plot(history$metrics$val_loss[2:69], type = "l", col = "red")
# lines(history$metrics$loss[2:69])
# dev.off()



